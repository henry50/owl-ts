import * as fs from "fs";

/*
run this with 
npx tsx ./src/_messagesGenerator.ts
*/

// add/edit messages here:
const messageSpecs: MessageMap = {
    RegistrationRequest: {
        pi: "bigint",
        T: "Point",
    },
    UserCredentials: {
        X3: "Point",
        PI3: "ZKP",
        pi: "bigint",
        T: "Point",
    },
    AuthInitRequest: {
        X1: "Point",
        X2: "Point",
        PI1: "ZKP",
        PI2: "ZKP",
    },
    AuthInitialValues: {
        T: "Point",
        pi: "bigint",
        x4: "bigint",
        X1: "Point",
        X2: "Point",
        X3: "Point",
        X4: "Point",
        beta: "Point",
        PI1: "ZKP",
        PI2: "ZKP",
        PI3: "ZKP",
        PIBeta: "ZKP",
    },
    AuthInitResponse: {
        X3: "Point",
        X4: "Point",
        PI3: "ZKP",
        PI4: "ZKP",
        beta: "Point",
        PIBeta: "ZKP",
    },
    AuthFinishRequest: {
        alpha: "Point",
        PIAlpha: "ZKP",
        r: "bigint",
    },
};

interface AttrMap {
    [key: string]: string;
}

interface MessageMap {
    [key: string]: AttrMap;
}

let template = `\
// THIS FILE IS GENERATED BY _messagesGenerator.ts
// DO NOT EDIT IT DIRECTLY AS IT WILL BE OVERWRITTEN

import { Config, Curves, Point, ZKP } from "./owl_common.js";
import { p256 } from "@noble/curves/p256";
import { p384 } from "@noble/curves/p384";
import { p521 } from "@noble/curves/p521";

function getCurve(curve: Curves) {
    return {
        [Curves.P256]: p256,
        [Curves.P384]: p384,
        [Curves.P521]: p521,
    }[curve];
}

function parseNum(x: any): bigint | null {
    try{
        return BigInt(\`0x\${x}\`);
    } catch {
        return null;
    }
}

function parsePoint(x: any, curve: Curves): Point | null {
    try{
        return getCurve(curve).ProjectivePoint.fromHex(x);
    } catch {
        return null;
    }
}

function parseZKP(x: any): ZKP | null {
    try {
        const [h, r] = [parseNum(x.h), parseNum(x.r)];
        if (h && r) {
            return { h, r };
        }
    } catch {}
    return null;
}

export class DeserializationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = "DeserializationError";
    }
}

`;

function indent(x: string, tabs: number): string {
    return "    ".repeat(tabs) + x;
}

for (const [cls, attrs] of Object.entries(messageSpecs)) {
    // export class ClassName {
    template += `export class ${cls} {\n`;
    // attr_1: type; ...; attr_n: type;
    const attrTypes: string[] = Object.entries(attrs).map(
        ([attr, t]) => `${attr}: ${t}`,
    );
    template += attrTypes.map((x) => indent(`${x};\n`, 1)).join("");
    // constructor(attr_1: type, ..., attr_n: type) {
    template += indent("constructor(", 1);
    template += attrTypes.join(", ");
    template += ") {\n";
    // [this.attr_1, ..., this.attr_n] = [attr_1, ..., attr_n]; }
    template += indent("[", 2);
    template += Object.keys(attrs)
        .map((x) => `this.${x}`)
        .join(", ");
    template += "] = [";
    template += Object.keys(attrs).join(", ");
    template += "];\n";
    template += indent("}\n", 1);
    // static deserialize(x: string, cfg: Config): ClassName | DeserializationError {
    template += indent("static deserialize(\n", 1);
    template += indent("x: any,\n", 2);
    template += indent("cfg: Config,\n", 2);
    template += indent(`): ${cls} | DeserializationError {\n`, 1);
    template += indent('if (typeof x == "string") {\n', 2);
    template += indent("x = JSON.parse(x);\n", 3);
    template += indent("}\n", 2);
    // const [attr_1, ..., attr_n] = [parsed.attr_1, ..., parsed.attr_n]
    template += indent("const [", 2);
    template += Object.keys(attrs).join(", ");
    template += "] = [\n";
    template += Object.entries(attrs)
        .map(([attr, t]) => {
            switch (t) {
                case "string":
                    return `x.${attr}`;
                case "bigint":
                    return `parseNum(x.${attr})`;
                case "Point":
                    return `parsePoint(x.${attr}, cfg.curve)`;
                case "ZKP":
                    return `parseZKP(x.${attr})`;
                default:
                    return `x.${attr}.toString()`;
            }
        })
        .map((x) => indent(x + ",", 3))
        .join("\n");
    template += "\n";
    template += indent("];\n", 2);
    template += indent("if (", 2);
    template += Object.keys(attrs)
        .map((attr) => `${attr} !== null`)
        .join(" && ");
    template += ") {\n";
    // return new this(attr_1, ..., attr_n)
    template += indent("return new this(", 3);
    template += Object.keys(attrs).join(", ");
    template += ");\n";
    template += indent("}\n", 2);
    template += indent("return new DeserializationError(\n", 2);
    template += indent(`"Failed to deserialize ${cls}: invalid data",\n`, 3);
    template += indent(");\n", 2);
    template += indent("}\n", 1);
    // serialize() {
    template += indent("serialize() {\n", 1);
    // return JSON.stringify({attr_1: attr_1.toString(), ...})
    template += indent("return {\n", 2);
    template += Object.entries(attrs)
        .map(([attr, t]) => {
            switch (t) {
                case "bigint":
                    return `${attr}: this.${attr}.toString(16)`;
                case "Point":
                    return `${attr}: this.${attr}.toHex()`;
                case "ZKP":
                    return `${attr}: { h: this.${attr}.h.toString(16), r: this.${attr}.r.toString(16) }`;
                default:
                    return `${attr}: this.${attr}`;
            }
        })
        .map((x) => indent(x + ",", 3))
        .join("\n");
    template += "\n";
    template += indent("};\n", 2);
    template += indent("}\n", 1);
    template += "}\n\n";
}

fs.writeFile("src/messages.ts", template, (err) => {
    if (err) throw err;
    console.log("messages.ts generated successfully");
});
