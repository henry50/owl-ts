import * as fs from "fs";

/*
run this with 
npx tsx ./src/_messagesGenerator.ts
*/

// add/edit messages here:
const messageSpecs: MessageMap = {
    RegistrationRequest: {
        username: "string",
        t: "BigNumber",
        pi: "BigNumber",
        T: "BigNumber"
    },
    UserCredentials: {
        X3: "BigNumber",
        PI3: "ZKP",
        pi: "BigNumber",
        T: "BigNumber"
    },
    AuthInitRequest: {
        X1: "BigNumber",
        X2: "BigNumber",
        PI1: "ZKP",
        PI2: "ZKP"
    },
    AuthInitialValues: {
        T: "BigNumber",
        pi: "BigNumber",
        x4: "BigNumber", 
        X1: "BigNumber",
        X2: "BigNumber",
        X3: "BigNumber",
        X4: "BigNumber",
        beta: "BigNumber",
        PI1: "ZKP",
        PI2: "ZKP",
        PI3: "ZKP",
        PIBeta: "ZKP"
    },
    AuthInitResponse: {
        X3: "BigNumber",
        X4: "BigNumber",
        PI3: "ZKP",
        PI4: "ZKP",
        beta: "BigNumber",
        PIBeta: "ZKP"
    },
    AuthFinishRequest: {
        alpha: "BigNumber",
        PIAlpha: "ZKP",
        r: "BigNumber"
    }
}

interface AttrMap {
    [key: string]: string;
}

interface MessageMap {
    [key: string]: AttrMap;
}

let template = `\
// THIS FILE IS GENERATED BY _messagesGenerator.ts
// DO NOT EDIT IT DIRECTLY AS IT WILL BE OVERWRITTEN

import BigNumber from "bignumber.js";
import { ZKP } from "./owl_common.js";

function parseNum(x: any): BigNumber | null {
    try{
        const n = BigNumber(x, 16);
        if(!n.isNaN()){
            return n;
        }
    } catch {}
    return null;
}

function parseZKP(x: any): ZKP | null {
    try{
        const [h, r] = [parseNum(x.h), parseNum(x.r)];
        if(h && r){
            return {h, r};
        }
    } catch {}
    return null;
}

export class DeserializationError extends Error {
    constructor(message: string) {
      super(message);
      this.name = "DeserializationError";
    }
}

`

function indent(x: string, tabs: number): string {
    return "    ".repeat(tabs) + x;
}

for(const [cls, attrs] of Object.entries(messageSpecs)){
    // export class ClassName {
    template += `export class ${cls} {\n`;
    // attr_1: type; ...; attr_n: type;
    const attrTypes: string[] = Object.entries(attrs).map(
        ([attr, t]) => `${attr}: ${t}`
    );
    template += attrTypes.map(
        x => indent(`${x};\n`, 1)
    ).join("");
    // constructor(attr_1: type, ..., attr_n: type) {
    template += indent("constructor(", 1);
    template += attrTypes.join(", ");
    template += "){\n";
    // [this.attr_1, ..., this.attr_n] = [attr_1, ..., attr_n]; }
    template += indent("[", 2);
    template += Object.keys(attrs).map(
        x => `this.${x}`
    ).join(", ");
    template += "] = [";
    template += Object.keys(attrs).join(", ");
    template += "];\n";
    template += indent("}\n", 1);
    // static deserialize(x: string): ClassName | DeserializationError {
    template += indent(`static deserialize(x: any): ${cls} | DeserializationError {\n`, 1);
    template += indent("if(typeof x == \"string\"){\n", 2);
    template += indent("x = JSON.parse(x);\n", 3);
    template += indent("}\n", 2);
    // const [attr_1, ..., attr_n] = [parsed.attr_1, ..., parsed.attr_n]
    template += indent("const [", 2);
    template += Object.keys(attrs).join(", ");
    template += "] = [\n";
    template += Object.entries(attrs).map(([attr, t]) => {
        switch(t){
            case "string":
                return `x.${attr}`;
            case "BigNumber":
                return `parseNum(x.${attr})`;
            case "ZKP":
                return `parseZKP(x.${attr})`;
            default:
                return `x.${attr}.toString()`;
        }
    }).map(x => indent(x, 3)).join(",\n");
    template += "\n";
    template += indent("];\n", 2);
    // if(attr_1 !== null && ... && attr_n !== null)
    template += indent("if(", 2);
    template += Object.keys(attrs).map(
        attr => `${attr} !== null`
    ).join(" && ");
    template += "){\n";
    // return new this(attr_1, ..., attr_n)
    template += indent("return new this(", 3);
    template += Object.keys(attrs).join(", ");
    template += ");\n";
    template += indent("}\n", 2);
    template += indent(
        `return new DeserializationError(\"Failed to deserialize ${cls}: invalid data\");\n`
    , 2);
    template += indent("}\n", 1);
    // serialize() {
    template += indent("serialize(){\n", 1);
    // return JSON.stringify({attr_1: attr_1.toString(), ...})
    template += indent("return {\n", 2);
    template += Object.entries(attrs).map(([attr, t]) => {
        switch(t){
            case "BigNumber":
                return `${attr}: this.${attr}.toString(16)`;
            case "ZKP":
                return `${attr}: {h: this.${attr}.h.toString(16), r: this.${attr}.r.toString(16)}`;
            default:
                return `${attr}: this.${attr}`;
        }
    }).map(x => indent(x, 3)).join(",\n");
    template += "\n";
    template += indent("};\n", 2);
    template += indent("}\n", 1);
    template += "}\n\n"
}

fs.writeFile("src/messages.ts", template, (err) => {
    if (err) throw err;
    console.log("messages.ts generated successfully");
});